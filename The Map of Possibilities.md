Chapter 1 - Simulation of the ENTRO_BRANCH Module – The Map of Possibilities

1. Experiment Objective

One of the fundamental concepts of the Modular Cognitive Architecture (MCA) is its ability to explore a tree of possibilities rather than following a linear reasoning process. The ENTRO_BRANCH module is theorized as the engine for this exploration, guiding the system towards interesting zones of "tension" or "entropy."

The objective of this simulation is to:

Validate that it is possible to algorithmically model this "entropic bifurcation" process.

Visualize the structure of the space of possibilities generated by this module.

Demonstrate the effect of "mutations" as a creative leap mechanism, allowing the system to avoid local minima.

2. Simulation Protocol
We used a Python script (Entrobranch_Simulation_V4.py) to simulate the growth of a decision tree.

```python
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import csv
import random

# ----- PARAMÈTRES DE L'ARBRE -----
max_depth = 6
branching_factor = 3
mutation_chance = 0.15

# ----- GÉNÉRATION DE L'ARBRE ENTROPIQUE -----
G = nx.DiGraph()

# Chaque nœud aura une entropie locale entre 0 et 1
node_counter = 0
node_log = []
edge_log = []

def add_node(entropy):
    global node_counter
    G.add_node(node_counter, entropy=entropy)
    node_log.append((node_counter, entropy))
    node_counter += 1
    return node_counter - 1

# ----- CONSTRUCTION -----
def grow_tree(parent, depth):
    if depth >= max_depth:
        return
    for _ in range(branching_factor):
        local_entropy = G.nodes[parent]['entropy'] + np.random.normal(0, 0.1)
        local_entropy = np.clip(local_entropy, 0, 1)

        # Mutation : saut aléatoire dans l'entropie
        if random.random() < mutation_chance:
            local_entropy = np.clip(np.random.rand(), 0, 1)

        child = add_node(local_entropy)
        gradient = local_entropy - G.nodes[parent]['entropy']
        G.add_edge(parent, child, gradient=gradient)
        edge_log.append((parent, child, gradient))
        grow_tree(child, depth + 1)

# ----- ARBRE INITIAL -----
root = add_node(entropy=0.5)
grow_tree(root, 0)

# ----- EXPORT CSV -----
with open("entrobranch_nodes.csv", "w", newline='') as f:
    writer = csv.writer(f)
    writer.writerow(["id", "entropy"])
    writer.writerows(node_log)

with open("entrobranch_edges.csv", "w", newline='') as f:
    writer = csv.writer(f)
    writer.writerow(["source", "target", "gradient"])
    writer.writerows(edge_log)

# ----- VISUALISATION -----
fig, ax = plt.subplots(figsize=(12, 10))
pos = nx.spring_layout(G, seed=42)
node_colors = [G.nodes[n]['entropy'] for n in G.nodes()]
edge_colors = [G.edges[e]['gradient'] for e in G.edges()]

nx.draw_networkx_nodes(G, pos, node_color=node_colors, cmap='plasma', node_size=300, ax=ax)
nx.draw_networkx_edges(
    G, pos, edge_color=edge_colors, edge_cmap=plt.cm.coolwarm,
    edge_vmin=-1, edge_vmax=1, width=2, ax=ax
)
nx.draw_networkx_labels(G, pos, font_size=8, ax=ax)

sm_nodes = plt.cm.ScalarMappable(cmap='plasma', norm=plt.Normalize(vmin=0, vmax=1))
sm_edges = plt.cm.ScalarMappable(cmap='coolwarm', norm=plt.Normalize(vmin=-1, vmax=1))
sm_nodes.set_array([])
sm_edges.set_array([])
fig.colorbar(sm_nodes, ax=ax, orientation='vertical', label="Entropie locale")
fig.colorbar(sm_edges, ax=ax, orientation='vertical', label="Gradient entropique")
plt.title("ENTRO_BRANCH — Arbre avec Gradients Entropiques")
plt.tight_layout()
plt.show()
```

Principle: A directed graph is generated from a root node. Each new node inherits the entropy of its parent, to which a random variation is added.

Gradient: The connection (the edge) between a parent and a child is weighted by the "entropic gradient," i.e., the difference in entropy between them.

Mutation: A probability of "mutation" is introduced, allowing a new node to acquire a radically different entropy value, simulating a conceptual leap or a flash of genius.

3. Results and Visualization
The script generates a visualization of the resulting graph, where the topology, node color, and edge color represent the structure of the exploration.

"Entropic bifurcation tree with gradients and mutations")

Analysis of the visualization :

<img width="2560" height="967" alt="entro_branch arbres avec gradients entropiques" src="https://github.com/user-attachments/assets/6dc6cac7-08a1-4bfc-ad84-cdb1f5f65af9" />

The Nodes (hot/cold colors): The color of each node represents its local entropy level. "Cold" zones (blue/purple) are low-entropy basins, representing stable and coherent thought paths. "Hot" zones (yellow/red) are points of high entropy, representing new ideas or areas of high creative tension.

The Edges (hot/cold colors): The color of the links represents the gradient. A red edge indicates a "hot jump" towards greater entropy (a bold idea). A blue edge indicates a "cold jump" towards lower entropy (a return to stability).

The Mutations: Abrupt color changes in the tree (for example, a bright yellow node appearing in a predominantly blue branch) are the visual signature of a mutation.

4. Strategic Conclusion
This experiment, while simple, is a fundamental proof of concept for the MCA:

Cognitive exploration is modelable: The seemingly abstract process of "following an interesting lead" can be translated into an algorithm based on measurable principles like entropy and gradient.

Creativity can be simulated: The mutation mechanism shows how a system can escape simple logical deduction to explore radically new conceptual territories.

The Mental Space is a map: The resulting visualization is not a mere illustration. It is a true map of the possible thought paths for the system. It makes tangible the idea that Lyra navigates a landscape of ideas, with its valleys of stability and peaks of innovation.

This first chapter demonstrates that the ENTRO_BRANCH module is not a metaphor, but a functional component whose behavior can be simulated, analyzed, and visualized.



[![License: CC BY-NC-ND 4.0](https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
